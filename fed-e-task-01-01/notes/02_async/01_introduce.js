// 1、同步模式 sync、异步模式 

// 异步模式： 异步模式的API是不会等待这个任务结束才开始下个任务，对于耗时任务是开始后，就立即往后执行下个任务，
            // 耗时任务的逻辑会通过回调函数的方式进行定义，在内部当耗时任务完成后会自动调用定义的回调函数
            // 很重要，可以同时处理大量的耗时任务
console.log('global began')

function bar () {
  console.log('bar task')
}

function foo () {
  console.log('foo task')
  bar()
}

foo()

console.log('global end')

// 以上按同步模式执行，执行完销毁



// 异步执行  通过回调函数的方式来定义，解决了同时处理大量耗时任务的问题
        // 执行顺序比较跳跃
        // js是单线程的，浏览器不是单线程


//异步模式：  调用栈、内部API环境（异步线程）、EventLoop、消息队列
      // 调用栈是一个正在执行的工作列表
      // 消息队列是一个待办的工作表
      // js执行引擎就是先去执行完调用栈中的任务，再通过EventLoop从消息队列中在取一个出来继续去执行，
          // 整个过程我们随时可以往消息队列中在放些任务，这些任务会在消息队列中排队等待时间循环

// 例代码调用： 函数进行依次执行每行代码
console.log('ggg') // 1、先进行压栈，然后执行、打印，完事后弹栈
setTimeout(function timer1(){ // 2、先进行压栈，然后调用，发现函数是个异步调用，此异步是在为timer1函数开启了一个计时器，将其单独放进内部环境进行执行，是单独工作的，并不影响主线程执行，setTimeout就已执行完成弹出
  console.log('timer1')  // 7、timer1从消息队列里被压入调用栈进行执行，执行完弹栈
}, 1800);

setTimeout(function timer2(){ // 3、先进行压栈，然后调用，发现函数是个异步调用，此异步是在为timer2函数开启了一个计时器，将其单独放进内部环境进行执行，是单独工作的，并不影响主线程执行，setTimeout就已执行完成弹出
  console.log('timer2')   // 5、 timer2从消息队列里被压入调用栈进行执行，执行完、弹栈
  setTimeout(function inner(){  // 6、 发现是异步，放回到异步环境里执行, 已执行完毕弹栈
    console.log('inner')  // 7、倒计时时间到，消息队列队列将inner压入调用栈执行函数.....以此往复
  }, 1000);
}, 1000);

console.log('ggg end') // // 4、先进行压栈，然后执行、打印，然后后弹栈

// 此时调用栈中所有的任务都结束了，EventLoop（负责监听调用栈和消息队列）就开始发挥作用了
    // 监听到调用栈已执行完，就会从消息队列里取出第一个回调函数，然后压入进调用栈，此时异步时间还没结束消息队列中还是空的，执行就暂停下来了
    // 内部环境中timer1、timer2一直在倒计时，当timer2先倒计时结束会被放进消息队列的第一位，timer1计时结束会放在消息队列的第二位，
    // 当EventLoop监听到消息队列里发生了变化，就会将消息队列里第一个timer2压入到调用栈中执行第5步